# <center>TIL<center>
## 2023/09/19(33일차)

# 오늘 배운 내용 :memo:

1. **백트래킹(Backtracking)**
  - 과정
    - 여러 가지 선택지(옵션)들이 존재하는 상황에서 한 가지를 선택한다.
    - 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.
    - 이런 선택을 반복하면서 최종 상태에 도달한다.
    - 올바른 선택을 계속하면 목표 상태(goal state)에 도달한다.
  - 백트래킹과 DFS와의 차이
    - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임(Prunning 가지치기)
    - 깊이 우선 탐색이 모든 경로를 추적하는 데 비해 백트래킹은 불필요한 경로를 조기에 차단
    - 깊이 우선 탐색을 가하기에는 경우의 수가 너무나 많다. 즉, N! 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 당연히 처리 불가능한 문제가 생긴다.
    - 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 Exponential Time을 요구하므로 처리 불가능
  - 알고리즘 절차
    1. 상태 공간 트리의 깊이 우선 검색을 실시한다.
    2. 각 노드가 유망한지를 점검한다.
    3. 만약 그 노드가 유망하지 않다면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.
  - 백트래킹의 기초적인 예시
    - ```python
      # { 1, 2, 3 } 집합에서 3개의 숫자를 선택하는 기본적인 예제
      # 이미 사용한 숫자는 사용하지 않도록
      arr = [1, 2, 3]
      path = [0] * 3

      def backtracking(cnt):
          # 기저 조건
          # 숫자 3개를 골랐을 때 종료
          if cnt == 3:
              print(*path)
              return

          for i in arr:
              # 가지치기 - 중복된 숫자 제거
              if i in path:
                  continue
              # 들어가기 전 로직 - 경로 저장장
              path[cnt] = i
              # 다음 재귀 함수 호출
              backtracking(cnt + 1)
              # 돌아와서 할 로직
              path[cnt] = 0

      backtracking(0)
      ```
    - 백트래킹 함수(재귀를 끝내는 기저 조건 - 반복문(가지치기 - 재귀 들어가기 전 - 다음 재귀 함수 호출 - 돌아와서 할 로직)) 구조는 비슷하다.

2. **힙(heap)**
  - 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
  - 최대 힙(max heap)
    - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
    - 부모 노드의 키 값 > 자식 노드의 키 값
    - 루트 노드 : 키 값이 가장 큰 노드
  - 최소 힙(min heap)
    - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
    - 부모 노드의 키 값 < 자식 노드의 키 값
    - 루트 노드 : 키 값이 가장 작은 노드
  - 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
  - 루트 노드의 원소를 삭제하여 반환한다.
  - 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.(우선순위 큐와 비교)
  - 힙을 활용하는 대표적인 2가지 예는 특별한 큐의 구현과 정렬이다.
  - 우선순위 큐를 구현하는 가장 효율적인 방법이 힙을 사용하는 것이다
    - 노드 하나의 추가/삭제가 시간 복잡도가 O(log N)이고, 최대값/최소값을 O(1)에 구할 수 있다.
    - 완전 정렬보다 관리 비용이 적다.
  - 배열을 통해 트리 형태를 쉽게 구현할 수 있다.
    - 부모나 자식 노드를 O(1) 연산으로 쉽게 찾을 수 있다.
    - n 위치에 있는 노드의 자식은 2n과 2n + 1에 위치한다.
    - 완전 이진 트리의 특성에 의해 추가/삭제의 위치는 자료의 시작과 끝 인덱스로 쉽게 판단할 수 있다.
  - 힙 정렬은 힙 자료구조를 이용해서 이진 탐색과 유사한 방법으로 수행된다.
    - 정렬을 위한 2단계
      1. 하나의 값을 힙에 삽입한다.(반복)
      2. 힙에서 순차적(오름차순)으로 값을 하나씩 제거한다.
    - 힙 정렬의 시간 복잡도
      - N개의 노드 삽입 연산 + N개의 노드 삭제 연산
      - 삽입과 삭제 연산은 각각 O(log N)이다.
      - 따라서, 전체 정렬은 O(N log N)이다.
    - 힙 정렬은 배열에 저장된 자료를 정렬하기에 유용하다.

3. **트리 삽입, 삭제 연산 코드**
  - ```python
      def enque(item):
      global hsize

      hsize += 1
      TREE[hsize] = item

      c = hsize
      p = c // 2

      while p and TREE[p] < TREE[c]:
          TREE[p], TREE[c] = TREE[c], TREE[p]
          c = p
          p = c // 2

      def deque():
          global hsize
          result = TREE[1]
          TREE[1] = TREE[hsize]
          hsize -= 1
          p = 1
          c = p * 2
          while c <= hsize:
              if c + 1 <= hsize and TREE[c] < TREE[c + 1]:
                  c = c + 1
              if TREE[p] < TREE[c]:
                  TREE[p], TREE[c] = TREE[c], TREE[p]
                  p = c
                  c = p * 2
              else:
                  break
          return result

      TREE = [0, 20, 15, 19, 4, 13, 11]
      TREE += [0] * 100
      hsize = 6
    ```